#!/usr/bin/env python3

"""
idk

Copyright: jnzigg
e-mail: jnzig@proton.me
Project: https://github.com/jnzigg/sway-anchor
License: GPL3

Dependencies: python-i3ipc>=2.2.1 (i3ipc-python)
"""

from i3ipc import Connection, Con, Event, events
from collections import deque
from functools import partial
from typing import NamedTuple, TypedDict

import json


class AnchorPair(NamedTuple):
    anchor: Con
    anchor_depth: int
    anchored: Con
    anchored_is_first_child: bool


class AnchorPairManager(TypedDict):
    anchor_pairs: deque[AnchorPair]
    focused_cache: Con


def find_fertile(origin: Con) -> tuple[Con, Con]:
    fertile = origin.parent
    while len(fertile.nodes) == 1 and fertile.type != "workspace":
        origin = fertile
        fertile = fertile.parent
    return (fertile, origin)


def anchor(anchored: Con) -> AnchorPair:
    def dive(c: Con, i: int, depth: int = -1) -> tuple[Con, int]:
        depth += 1
        # c is a window
        if c.orientation == "none":
            return c, depth
        return dive(c.nodes[i], i, depth)

    fertile, origin = find_fertile(anchored)
    o_i = fertile.nodes.index(origin)
    aifc = o_i == 0

    if aifc:
        anchor, depth = dive(fertile.nodes[1], 0)
        return AnchorPair(anchor, depth, anchored, aifc)
    else:
        anchor, depth = dive(fertile.nodes[o_i - 1], -1)
        return AnchorPair(anchor, depth, anchored, aifc)


def on_focus(i3: Connection, e: events.WindowEvent, apm: AnchorPairManager) -> None:
    apm["focused_cache"] = i3.get_tree().find_focused()


def on_move(i3: Connection, e: events.WindowEvent, apm: AnchorPairManager) -> None:
    apm["anchor_pairs"].append(anchor(apm["focused_cache"]))


def on_undo(i3: Connection, e: events.TickEvent, apm: AnchorPairManager) -> None:
    if not apm["anchor_pairs"]:
        return

    ap = apm["anchor_pairs"].pop()

    i3.command(f'[con_id={ap.anchor.id}] mark --add anchor;'
               f'[con_id={ap.anchored.id}] move container to mark anchor,'
               f'focus;'
               f'unmark anchor')

    direction = {
        (True, "horizontal"): "left",
        (True, "vertical"): "up",
        (False, "horizontal"): "right",
        (False, "vertical"): "down",
    }

    def fix_position(direction: str, times: int):
        for _ in range(times):
            i3.command(f'move {direction}')

    adf, _ = find_fertile(ap.anchored)
    # immediate siblings
    if adf == ap.anchor.parent:
        if ap.anchored_is_first_child:
            fix_position(direction.get((ap.anchored_is_first_child, ap.anchor.parent.orientation)), 1)
        else:
            fix_position(direction.get((ap.anchored_is_first_child, ap.anchor.parent.orientation)), 0)
    else:
        if adf.orientation == ap.anchor.parent.orientation:
            fix_position(direction.get((ap.anchored_is_first_child, adf.orientation)), ap.anchor_depth)
        else:
            fix_position(direction.get((ap.anchored_is_first_child, adf.orientation)), ap.anchor_depth)

    apm["focused_cache"] = i3.get_tree().find_focused()


def tick_event_router(i3: Connection, e: events.TickEvent, apm: AnchorPairManager):
    if e.first:
        return

    payload = json.loads(e.payload)
    if payload["change"] != "sway-anchor":
        return

    match payload["command"]:
        case "undo":
            i3.main_quit()
            on_undo(i3, e, apm)
            i3.main()
        case "pause":
            i3.main_quit()
        case "start":
            i3.main()


def main():
    i3 = Connection()
    apm: AnchorPairManager = {"anchor_pairs": deque(maxlen=3), "focused_cache": None}

    on_focus_p = partial(on_focus, apm=apm)
    i3.on(Event.WINDOW_FOCUS, on_focus_p)

    on_move_p = partial(on_move, apm=apm)
    i3.on(Event.WINDOW_MOVE, on_move_p)

    tick_event_router_p = partial(tick_event_router, apm=apm)
    i3.on(Event.TICK, tick_event_router_p)

    i3.main()


if __name__ == "__main__":
    main()

